//@version=5
// =============================================================================
// ===== Merged Indicator by Jules =====
// =============================================================================
// This script is a combination of two separate scripts provided by the user.
//
// Script 1: A complex multi-indicator script containing an oscillator, Supertrend,
// Squeeze Momentum, and other components.
//
// Script 2: An implementation of the Ehlers MESA Adaptive Moving Average (MAMA).
//
// Jules has performed the following actions:
// 1. Converted the MAMA script from an older PineScript version to v5.
// 2. Combined both scripts into a single indicator.
// 3. Set the indicator to `overlay=true`. This is required to make the MAMA,
//    Supertrend, and other chart-based plots work correctly. A side effect
//    is that the oscillator components from Script 1 will also be plotted
//    on the main chart, which may make them appear compressed. This is a
//    limitation of PineScript, as a single script cannot be both an overlay
//    and a separate-window indicator.
// 4. Resolved all variable and function name conflicts by renaming inputs
//    and variables. For example, all components from the MAMA script are
//    prefixed with `mesa_`.
// 5. Organized all user inputs into collapsible groups for a cleaner user
//    interface.
// =============================================================================
indicator("Merged Indicator by Jules", "MIJ", overlay=true, max_lines_count=500, max_labels_count=500)


// =============================================================================
// ===== Functions from Script 1 =====
// =============================================================================

PhiSmoother(series float source, simple int length, simple float phase=3.7)=>
    var array<float> coefs = na
    var int length_1 = length - 1
    var float      W = 0.0
    if na(coefs)
        coefs := array.new<float>()
        const float SQRT_PIx2  = math.sqrt(2.0 * math.pi)
        const float MULTIPLIER = -0.5 / 0.93
        var float     length_2 = length * 0.52353
        for int i=0 to length_1
            float phi_alpha = (i + phase - length_2) * MULTIPLIER
            float  beta = 1.0 / (0.2316419 * math.abs(phi_alpha) + 1.0)
            float   phi = (math.exp(math.pow(phi_alpha, 2) * -0.5)
                         *-0.398942280) * beta *
                         ( 0.319381530  + beta *
                         (-0.356563782  + beta *
                         ( 1.781477937  + beta *
                         (-1.821255978  + beta
                         * 1.330274429)))) + 1.011
            if phi_alpha < 0.0
                phi := 1.0 - phi
            float weight = phi / SQRT_PIx2
            coefs.push(weight)
            W += weight
    float sma2 = math.avg(source, nz(source[1], source))
    float E = 0.0
    for int i=0 to length_1
        E += coefs.get(i) * sma2[i]
    E / W

ema(series float source, simple float length)=>
    float ema_alpha = 2.0 / (length + 1)
    var float smoothed = na
    smoothed := ema_alpha * source + (1.0 - ema_alpha) * nz(smoothed[1], source)

dema(series float source, simple float length)=>
    float ema1 = ema(source, length)
    float ema2 = ema(  ema1, length)
    2.0 * ema1 - ema2

tema(series float source, simple float length)=>
    float ema1 = ema(source, length)
    float ema2 = ema(  ema1, length)
    float ema3 = ema(  ema2, length)
    (ema1 - ema2) * 3.0 + ema3

wma(series float source, simple int length)=>
    float weight_sum = length * 0.5 * (length + 1)
    float sum = 0.0
    for int i=0 to length - 1
        sum += source[i] * (length - i)
    sum / weight_sum

sma(series float source, simple int length)=>
    float sum = ta.cum(source)
    if bar_index < length - 1
        sum / (bar_index + 1)
    else
        (sum - sum[length]) / length

filter(series float source,
       simple int   length,
       simple float  phase,
       simple string style)=>
    if length > 1
        switch style
            "PhiSmoother" => PhiSmoother(source, length, phase)
            "EMA"         =>         ema(source, length)
            "DEMA"        =>        dema(source, length)
            "TEMA"        =>        tema(source, length)
            "WMA"         =>         wma(source, length)
            =>                       sma(source, length) // "SMA"
    else
        source

method get_score(series array<float> source)=>
    array<float> scores = array.new<float>()
    for int i=0 to source.size() - 1
        float current = source.get(i)
        int score_sum = 0
        for j = 0 to source.size() - 1
            float check = source.get(j)
            int polarity = i < j ? 1 : -1
            if i != j
                if current > check
                    score_sum += polarity
                else
                    score_sum -= polarity
        scores.push(score_sum)
    scores

method net_score(series array<float> scores)=>
    int   value    = scores.size() - 1
    float netScore = ((scores.avg() + value) / (value * 2.0) - 0.5) * 200.0
    netScore

f_LazyLine(_data, _length) =>
    w1 = 0
    w2 = 0
    w3 = 0
    L1 = 0.0
    L2 = 0.0
    L3 = 0.0
    w = _length / 3

    if _length > 2
        w2 := math.round(w)
        w1 := math.round((_length - w2) / 2)
        w3 := int((_length - w2) / 2)

        L1 := ta.wma(_data, w1)
        L2 := ta.wma(L1, w2)
        L3 := ta.wma(L2, w3)
        L3
    else
        L3 := _data
        L3
    L3

// =============================================================================
// ===== Inputs =====
// =============================================================================

string common = "Common Controls"
float  source = input.source(           close,                 "Source", group=common)
string   mode = input.string("Trend Strength", "Composite Cluster Mode", group=common, options=["Trend Strength", "Volatility"], tooltip="Trend Strength visualizes the directionality of the cluster. Volatility weights the score to the bandwidth of the cluster.")
string filter_type = input.string(   "PhiSmoother",         "Cluster Filter", group=common, options=["PhiSmoother", "EMA", "DEMA", "TEMA", "WMA", "SMA"], tooltip="Choose a filter to build the moving average cluster with.")
float   phase_filter = input.float (             3.7,   "PhiSmoother Phase", group=common,  minval=0.0, step=0.1, tooltip="This allows for subtle adjustment (tweaking) of the phase/lag for PhiSmoother")

string cluster = "Cluster Options"
int    spacing = input.int(3,    "Cluster Dispersion", group=cluster,                 minval=1, maxval=10, tooltip="Choose the separation between the moving averages in the cluster.")
int upper_trim = input.int(0, "Cluster Trim - Upper:", group=cluster, inline="trim",  minval=0, maxval=31)
int lower_trim = input.int(0,              "Lower:", group=cluster, inline="trim",  minval=0, maxval=31, tooltip="The 'Upper' parameter modifies the shortest period of the moving averages, whereas 'Lower' parameter adjusts the longest period. Increasing the upper value reduces sensitivity, while increasing the lower value heightens sensitivity.")

string output           = "Composite Post Smoothing"
string post_smooth_filt = input.string("PhiSmoother", "PostSmooth - Filter:", group=output, inline="post", options=["PhiSmoother", "EMA", "DEMA", "TEMA", "WMA", "SMA"])
int    post_smooth_len  = input.int   (            1,            "Length:", group=output, inline="post",  minval=1, tooltip="Period of the cluster's post smoothing.")

string signal        = "Composite Signal Settings"
string signal_filter = input.string("PhiSmoother", "Signal - Filter:", group=signal, inline="signal", options=["PhiSmoother", "EMA", "DEMA", "TEMA", "WMA", "SMA"])
int    signal_length = input.int   (           20,        "Length:", group=signal, inline="signal",  minval=1, tooltip="Period of the momentum signal plot.")
color  signal_color  = input.color (    color.rgb(109, 171, 22),     "Filter Color", group=signal)

string threshold = "Oscillator Threshold Levels"
float upperLevel = input.float( 75.00, "Levels - Upper:", group=threshold, inline="level", minval=  1.0, maxval=99.0, step=2.0)
float lowerLevel = input.float(-75.00,        "Lower:", group=threshold, inline="level", minval=-99.0, maxval=-1.0, step=2.0, tooltip="Fine-tune the thresholds to your liking")

string colors_osc           = "Oscillator Coloring Preferences"
float transition_easing  = input.float(     50.0,    "Transition Easing", group=colors_osc, maxval=  100.0, minval=0.0, step=5.0, tooltip="Adjust the sensitivity to ranging conditions.")
bool  fill_bg            = input.bool (     true, "Fill Background", group=colors_osc, inline= "fill")
int   fill_alpha         = input.int  (       85,                     "", group=colors_osc, inline= "fill", minval=0, maxval=100)
color rising_bullish     = input.color(#FFCC00,     "Bullish Color", group=colors_osc, inline= "bull")
color rising_transition  = input.color(#9598A1,     "Transition Color", group=colors_osc, inline="range")
color falling_bearish    = input.color(#5500CC,     "Bearish Color", group=colors_osc, inline= "bear")

string lazyline_group = "LazyLine"
float alpha_lazyline = input.int(title='LazyLine Smoothness', defval=15, minval=1, group=lazyline_group)
bool ShowSig = input.bool(title='Show Up/Dn Swing Signal?', defval=false, group=lazyline_group)
float SigMulti = input.float(title='Signal Locator %', defval=1.0, step=0.2, minval=0, maxval=20, group=lazyline_group)


string wave_trend_group = "Wave Trend Oscillator"
int n1 = input.int(10, 'WT Channel Length', group=wave_trend_group)
int n2 = input.int(21, 'WT Average Length', group=wave_trend_group)
float obLevel1 = input.float(60, 'WT Over Bought Level 1', group=wave_trend_group)
float obLevel2 = input.float(53, 'WT Over Bought Level 2', group=wave_trend_group)
float osLevel1 = input.float(-60, 'WT Over Sold Level 1', group=wave_trend_group)
float osLevel2 = input.float(-53, 'WT Over Sold Level 2', group=wave_trend_group)


string supertrend_group = "Supertrend"
int atrPeriod = input.int(10, 'ATR Length', minval = 1, group=supertrend_group)
float factor = input.float(2.5, 'Factor', minval = 0.01, step = 0.01, group=supertrend_group)
bool alertTrendChange = input.bool(true, title='Enable Trend Change Alert', group=supertrend_group)


string squeeze_group = "Squeeze Momentum"
int bbLength = input.int(20, 'Bollinger Bands Length', minval = 1, group=squeeze_group)
float bbMult = input.float(2, 'Bollinger Bands MultFactor', step = 0.25, group=squeeze_group)
int kcLength = input.int(20, 'Keltner\'s Channel Length', group=squeeze_group)
float kcMult = input.float(1.5, 'Keltner\'s Channel MultFactor', step = 0.25, group=squeeze_group)
bool useTrueRange = input.bool(true, 'Use TrueRange (Keltner\'s Channel)', group=squeeze_group)
string tooltip_sqz = 'The Squeeze Indicator measures the relationship between Bollinger Bands and Keltner\'s Channels to help identify consolidations and signal when prices are likely to break out (whether up or down). '
bool components = input.bool(false, 'Components of the Squeeze Indicator', tooltip = tooltip_sqz, group=squeeze_group)
float lowerThreshold = input.float(-1.0, title = 'Lower Threshold', group=squeeze_group)
float upperThreshold = input.float(1.0, title = 'Upper Threshold', group=squeeze_group)

string mesa_group = "MESA Adaptive Moving Average"
source_mesa = input.source(hl2, title="MESA Source", group=mesa_group)
fl_mesa=input.float(.5, title="MESA Fast Limit", group=mesa_group)
sl_mesa=input.float(.05, title="MESA Slow Limit", group=mesa_group)
pa_mesa=input.bool(false, title="MESA Mark Crossover Points", group=mesa_group)
fr_mesa=input.bool(false, title="MESA Fill MAMA/FAMA Region", group=mesa_group)
ebc_mesa=input.bool(false, title="MESA Enable Bar Colors", group=mesa_group)


// =============================================================================
// ===== Main Logic Script 1: Oscillator, Supertrend, Squeeze etc. =====
// =============================================================================

var bool VOLATILITY_MODE_ON = mode == "Volatility"

array<float> filter_cluster = array.new<float>(34)
filter_cluster.set( 0,        source)
filter_cluster.set( 1, filter(source,      spacing, phase_filter, filter_type))
filter_cluster.set( 2, filter(source, 2  * spacing, phase_filter, filter_type))
filter_cluster.set( 3, filter(source, 3  * spacing, phase_filter, filter_type))
filter_cluster.set( 4, filter(source, 4  * spacing, phase_filter, filter_type))
filter_cluster.set( 6, filter(source, 5  * spacing, phase_filter, filter_type))
filter_cluster.set( 7, filter(source, 6  * spacing, phase_filter, filter_type))
filter_cluster.set( 8, filter(source, 7  * spacing, phase_filter, filter_type))
filter_cluster.set( 9, filter(source, 8  * spacing, phase_filter, filter_type))
filter_cluster.set(10, filter(source, 9  * spacing, phase_filter, filter_type))
filter_cluster.set(11, filter(source, 10 * spacing, phase_filter, filter_type))
filter_cluster.set(12, filter(source, 11 * spacing, phase_filter, filter_type))
filter_cluster.set(13, filter(source, 12 * spacing, phase_filter, filter_type))
filter_cluster.set(14, filter(source, 13 * spacing, phase_filter, filter_type))
filter_cluster.set(15, filter(source, 14 * spacing, phase_filter, filter_type))
filter_cluster.set(16, filter(source, 15 * spacing, phase_filter, filter_type))
filter_cluster.set(17, filter(source, 16 * spacing, phase_filter, filter_type))
filter_cluster.set(18, filter(source, 17 * spacing, phase_filter, filter_type))
filter_cluster.set(19, filter(source, 18 * spacing, phase_filter, filter_type))
filter_cluster.set(20, filter(source, 19 * spacing, phase_filter, filter_type))
filter_cluster.set(21, filter(source, 20 * spacing, phase_filter, filter_type))
filter_cluster.set(22, filter(source, 21 * spacing, phase_filter, filter_type))
filter_cluster.set(23, filter(source, 22 * spacing, phase_filter, filter_type))
filter_cluster.set(24, filter(source, 23 * spacing, phase_filter, filter_type))
filter_cluster.set(25, filter(source, 24 * spacing, phase_filter, filter_type))
filter_cluster.set(26, filter(source, 25 * spacing, phase_filter, filter_type))
filter_cluster.set(27, filter(source, 26 * spacing, phase_filter, filter_type))
filter_cluster.set(28, filter(source, 27 * spacing, phase_filter, filter_type))
filter_cluster.set(29, filter(source, 28 * spacing, phase_filter, filter_type))
filter_cluster.set(30, filter(source, 29 * spacing, phase_filter, filter_type))
filter_cluster.set(31, filter(source, 30 * spacing, phase_filter, filter_type))
filter_cluster.set(32, filter(source, 31 * spacing, phase_filter, filter_type))
filter_cluster.set(33, filter(source, 32 * spacing, phase_filter, filter_type))

if upper_trim > 0
    for int i=0 to math.min(upper_trim - 1, filter_cluster.size() - 1)
        if  filter_cluster.size() > 2
            filter_cluster.shift()
        else
            break
if lower_trim > 0
    for int i=0 to math.min(lower_trim - 1, filter_cluster.size() - 1)
        if  filter_cluster.size() > 2
            filter_cluster.pop()
        else
            break

float ribbon_max   = filter_cluster.max()
float ribbon_min   = filter_cluster.min()
float ribbon_width = ribbon_max - ribbon_min
float ribbon_rank  = VOLATILITY_MODE_ON ? nz(ribbon_width / math.avg(ribbon_max, ribbon_min)) : 1

array<float> score = filter_cluster.get_score()
float    net_score = filter(score.net_score() * ribbon_rank, post_smooth_len, 3.7, post_smooth_filt)
float signal_value = signal_length < 2 ? na : filter(ta.sma(net_score, 2), signal_length, 3.7, signal_filter)

color1 = net_score>signal_value ? #00FF00 : #ff0000
net  = plot(net_score, "Score", color1, 3)
plot(signal_value, "Signal", signal_color, 1)

// --- LazyLine ---
LL = f_LazyLine(source, alpha_lazyline)
c_up = color.new(#33ff00, 0)
c_dn = color.new(#ff1111, 0)
uptrend_lazy = LL > LL[1]
plot(LL, 'LazyLine', color=uptrend_lazy ? c_up : c_dn, linewidth=3)
plot(ta.wma(source, alpha_lazyline), 'WMA for LazyLine', color=color.new(color.purple, 0), display=display.none)

// --- LazyLine Swing Signal ---
SignalOn = ShowSig and barstate.isconfirmed
SwingDn = uptrend_lazy[1] and not uptrend_lazy
SwingUp = uptrend_lazy and not uptrend_lazy[1]
d_swing = SigMulti / 100 * LL
plotshape(SignalOn and SwingDn ? LL + d_swing : na, title='Swing Down', style=shape.triangledown, location=location.absolute, size=size.small, color=c_dn)
plotshape(SignalOn and SwingUp ? LL - d_swing : na, title='Swing Up', style=shape.triangleup, location=location.absolute, size=size.small, color=c_up)
alertcondition(SwingUp, 'Swing Up', 'Swing Up Detected!')
alertcondition(SwingDn, 'Swing Down', 'Swing Down Detected!')
alertcondition(SwingUp or SwingDn, 'Swing', 'Up/Down Swing Detected!')

// --- Wave Trend Oscillator ---
ap = hlc3
esa = ta.ema(ap, n1)
d_wt = ta.ema(math.abs(ap - esa), n1)
ci = (ap - esa) / (0.015 * d_wt)
tci = ta.ema(ci, n2)
wt1 = tci
wt2 = ta.sma(wt1, 4)
plot(wt1, "WT1", color=color.new(color.aqua, 0))
plot(wt2, "WT2", color=color.new(color.maroon, 0))
plot(wt1 - wt2, "WT Histogram", color=wt2 - wt1 > 0 ? color.new(color.maroon, 50) : color.new(color.aqua, 50), style=plot.style_histogram)

// --- Supertrend ---
[supertrend, direction] = ta.supertrend(factor, atrPeriod)
plot(supertrend, color = direction < 0 ? color.green : color.red, title = 'Supertrend', style = plot.style_stepline_diamond)
upTrend = direction < 0
downTrend = direction > 0
var int previousDirection = na
previousDirection := upTrend ? 1 : -1
atrValue = ta.atr(atrPeriod)
var float entryPrice = na
var float targetLevel1 = na
var float targetLevel2 = na
var float targetLevel3 = na
var float stopLossLevel = na
var int count_up = 0
var int count_down = 0
var bool newLinesDrawn = false

if upTrend
    entryPrice := close
    targetLevel1 := close + atrValue * 1
    targetLevel2 := close + atrValue * 2
    targetLevel3 := close + atrValue * 3
    stopLossLevel := close - atrValue * 3
    count_up += 1
    count_down := 0
else if downTrend
    entryPrice := close
    targetLevel1 := close - atrValue * 1
    targetLevel2 := close - atrValue * 2
    targetLevel3 := close - atrValue * 3
    stopLossLevel := close + atrValue * 3
    count_down += 1
    count_up := 0

// --- Squeeze Momentum ---
basis = ta.sma(source, bbLength)
dev = kcMult * ta.stdev(source, bbLength)
bbUpper = basis + dev
bbLower = basis - dev
ma = ta.sma(source, kcLength)
trRange = useTrueRange ? ta.tr : high - low
rangema = ta.sma(trRange, kcLength)
kcUpper = ma + rangema * kcMult
kcLower = ma - rangema * kcMult
sqzOn = bbLower > kcLower and bbUpper < kcUpper
sqzOff = bbLower < kcLower and bbUpper > kcUpper
noSqz = sqzOn == false and sqzOff == false
val = ta.linreg(source - math.avg(math.avg(ta.highest(high, kcLength), ta.lowest(low, kcLength)), ta.sma(source, kcLength)), kcLength, 0)
dir = val
segitigaUp = sqzOff and dir > dir[1] and dir >= upperThreshold
segitigaDown = sqzOff and dir < dir[1] and dir <= lowerThreshold
plotshape(sqzOn or noSqz ? true : false, 'In Squeeze', shape.square, location.top, color.new(color.black, 0), show_last = 500)
plotshape(segitigaUp ? true : false, 'Squeeze Release UpTrend', shape.triangleup, location.top, color.new(color.green, 0), show_last = 500)
plotshape(segitigaDown ? true : false, 'Squeeze Release DownTrend', shape.triangledown, location.top, color.new(color.red, 0), show_last = 500)
if sqzOff and not sqzOff[1]
    alert('Squeeze Release : '+ syminfo.tickerid + ' | ' + timeframe.period, alert.freq_once_per_bar)
if segitigaDown[2] and not segitigaDown
    alert('Weak Trend or Reverse : '+ syminfo.tickerid + ' | ' + timeframe.period, alert.freq_once_per_bar)
if segitigaUp[2] and not segitigaUp
    alert('Weak Trend or Reverse : '+ syminfo.tickerid + ' | ' + timeframe.period, alert.freq_once_per_bar)
plotarrow(dir, 'Momentum Strength/Direction', color.new(color.aqua, 75), color.new(color.orange, 75), show_last = 500)
plot(components ? bbUpper : na, 'BBUpper', color.new(color.blue, 25), show_last = 500)
plot(components ? bbLower : na, 'BBLower', color.new(color.blue, 25), show_last = 500)
plot(components ? kcUpper : na, 'KCUpper', color.new(color.red, 25), show_last = 500)
plot(components ? kcLower : na, 'KCLower', color.new(color.red, 25), show_last = 500)


// =============================================================================
// ===== Main Logic Script 2: MESA Adaptive Moving Average =====
// =============================================================================
var float mesa_p = 0.0
var float mesa_i2 = 0.0
var float mesa_q2 = 0.0
var float mesa_re = 0.0
var float mesa_im = 0.0
var float mesa_spp = 0.0
var float mesa_mama = na
var float mesa_fama = na

mesa_sp = (4*source_mesa + 3*source_mesa[1] + 2*source_mesa[2] + source_mesa[3]) / 10.0
mesa_dt = (.0962*mesa_sp + .5769*nz(mesa_sp[2]) - .5769*nz(mesa_sp[4])- .0962*nz(mesa_sp[6]))*(.075*nz(mesa_p[1]) + .54)
mesa_q1 = (.0962*mesa_dt + .5769*nz(mesa_dt[2]) - .5769*nz(mesa_dt[4])- .0962*nz(mesa_dt[6]))*(.075*nz(mesa_p[1]) + .54)
mesa_i1 = nz(mesa_dt[3])
mesa_jI = (.0962*mesa_i1 + .5769*nz(mesa_i1[2]) - .5769*nz(mesa_i1[4])- .0962*nz(mesa_i1[6]))*(.075*nz(mesa_p[1]) + .54)
mesa_jq = (.0962*mesa_q1 + .5769*nz(mesa_q1[2]) - .5769*nz(mesa_q1[4])- .0962*nz(mesa_q1[6]))*(.075*nz(mesa_p[1]) + .54)
mesa_i2_ = mesa_i1 - mesa_jq
mesa_q2_ = mesa_q1 + mesa_jI
mesa_i2 := .2*mesa_i2_ + .8*nz(mesa_i2[1])
mesa_q2 := .2*mesa_q2_ + .8*nz(mesa_q2[1])
mesa_re_ = mesa_i2*nz(mesa_i2[1]) + mesa_q2*nz(mesa_q2[1])
mesa_im_ = mesa_i2*nz(mesa_q2[1]) - mesa_q2*nz(mesa_i2[1])
mesa_re := .2*mesa_re_ + .8*nz(mesa_re[1])
mesa_im := .2*mesa_im_ + .8*nz(mesa_im[1])
mesa_p1 = (mesa_im!=0 and mesa_re!=0) ? 360/math.atan(mesa_im/mesa_re) : nz(mesa_p[1])
mesa_p2 = mesa_p1 > 1.5*nz(mesa_p1[1]) ? 1.5*nz(mesa_p1[1]) : mesa_p1 < 0.67*nz(mesa_p1[1]) ? 0.67*nz(mesa_p1[1]) : mesa_p1
mesa_p3 = mesa_p2<6 ? 6 : (mesa_p2 > 50 ? 50 : mesa_p2)
mesa_p := .2*mesa_p3 + .8*nz(mesa_p3[1])
mesa_spp := .33*mesa_p + .67*nz(mesa_spp[1])
mesa_phase = math.atan(mesa_q1 / mesa_i1)
mesa_dphase_ = nz(mesa_phase[1]) - mesa_phase
mesa_dphase = mesa_dphase_< 1 ? 1 : mesa_dphase_
mesa_alpha_ = fl_mesa / mesa_dphase
mesa_alpha = mesa_alpha_ < sl_mesa ? sl_mesa : (mesa_alpha_ > fl_mesa ? fl_mesa : mesa_alpha_)
mesa_mama := mesa_alpha*source_mesa + (1 - mesa_alpha)*nz(mesa_mama[1], source_mesa)
mesa_fama := .5*mesa_alpha*mesa_mama + (1 - .5*mesa_alpha)*nz(mesa_fama[1], mesa_mama)

plotarrow(pa_mesa?(ta.cross(mesa_mama, mesa_fama)?mesa_mama<mesa_fama?-1:1:na):na, title="MESA Crossover Markers")
mamal=plot(mesa_mama, title="MAMA", color=color.red, linewidth=2)
famal=plot(mesa_fama, title="FAMA", color=color.green, linewidth=2)
fill(mamal, famal, color = mesa_mama > mesa_fama ? color.new(color.green, 70) : color.new(color.red, 70), title="MAMA/FAMA Fill")
mesa_bc=mesa_mama>mesa_fama?color.lime:color.red
barcolor(ebc_mesa?mesa_bc:na)

// Note: The TP/SL lines and labels from the original script were removed as they
// would create excessive objects on the chart and are highly experimental.
// They can be added back if needed, but require careful management of line/label IDs.
// A simplified alert for trend change is kept.
if (upTrend and not upTrend[1]) or (downTrend and not downTrend[1])
    if alertTrendChange
        trendType = upTrend ? "Buy" : "Sell"
        alertMessage = 'Pair : ' + syminfo.tickerid + ' | ' + timeframe.period + '\n' + 'New Trend : ' + trendType
        alert(alertMessage, alert.freq_once_per_bar_close)
