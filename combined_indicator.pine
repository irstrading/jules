//@version=6
indicator("All-in-One Indicator", shorttitle="AIO", overlay=false)

// --- Master Toggles ---
string master_group = "--- MASTER ON/OFF SWITCHES ---"
bool show_oscillator = input.bool(true, "Show Oscillator", group = master_group, inline = "1")
bool show_vwap_zscore = input.bool(true, "Show VWAP Z-Score", group = master_group, inline = "1")
bool show_stddev_helper = input.bool(true, "Show StdDev Volatility Helper", group = master_group, inline = "1")

// --- Oscillator Indicator ---
if show_oscillator
    string osc_group = "--- OSCILLATOR SETTINGS ---"
    string osc_common = "Common Controls"
    float  osc_source = input.source(           close,                 "Source", group=osc_common)
    string   osc_mode = input.string("Trend Strength", "Composite Cluster Mode", group=osc_common, options=["Trend Strength", "Volatility"], tooltip="Trend Strength visualizes the directionality of the filter cluster. Volatility weights the score to the bandwidth of the cluster.")
    string osc_filter_type = input.string(   "PhiSmoother",         "Cluster Filter", group=osc_common, options=["PhiSmoother", "EMA", "DEMA", "TEMA", "WMA", "SMA"], tooltip="Choose a filter to build the moving average cluster with.")
    float   osc_phase = input.float (             3.7,   "PhiSmoother Phase", group=osc_common,  minval=0.0, step=0.1, tooltip="This allows for subtle adjustment (tweaking) of the phase/lag for PhiSmoother")

    string osc_cluster = "Cluster Options"
    int    osc_spacing = input.int(3,    "Cluster Dispersion", group=osc_cluster,                 minval=1, maxval=10, tooltip="Choose the separation between the moving averages in the cluster.")
    int osc_upper_trim = input.int(0, "Cluster Trim - Upper:", group=osc_cluster, inline="trim",  minval=0, maxval=31)
    int osc_lower_trim = input.int(0,              "Lower:", group=osc_cluster, inline="trim",  minval=0, maxval=31, tooltip="The 'Upper' parameter modifies the shortest period of the moving averages, whereas 'Lower' parameter adjusts the longest period. Increasing the upper value reduces sensitivity, while increasing the lower value heightens sensitivity.")

    string osc_output           = "Composite Post Smoothing"
    string osc_post_smooth_filt = input.string("PhiSmoother", "PostSmooth - Filter:", group=osc_output, inline="post", options=["PhiSmoother", "EMA", "DEMA", "TEMA", "WMA", "SMA"])
    int    osc_post_smooth_len  = input.int   (            1,            "Length:", group=osc_output, inline="post",  minval=1, tooltip="Period of the cluster's post smoothing.")

    string osc_signal        = "Composite Signal Settings"
    string osc_signal_filter = input.string("PhiSmoother", "Signal - Filter:", group=osc_signal, inline="signal", options=["PhiSmoother", "EMA", "DEMA", "TEMA", "WMA", "SMA"])
    int    osc_signal_length = input.int   (           20,        "Length:", group=osc_signal, inline="signal",  minval=1, tooltip="Period of the momentum signal plot.")
    color  osc_signal_color  = input.color (    color.rgb(109, 171, 22),     "Filter Color", group=osc_signal)

    string osc_threshold = "Threshold Levels"
    float osc_upperLevel = input.float( 75.00, "Levels - Upper:", group=osc_threshold, inline="level", minval=  1.0, maxval=99.0, step=2.0)
    float osc_lowerLevel = input.float(-75.00,        "Lower:", group=osc_threshold, inline="level", minval=-99.0, maxval=-1.0, step=2.0, tooltip="Fine-tune the thresholds to your liking")

    string osc_colors            = "Coloring Preferences"
    float osc_transition_easing  = input.float(     50.0,    "Transition Easing", group=osc_colors, maxval=  100.0, minval=0.0, step=5.0, tooltip="Adjust the sensitivity to ranging conditions.")
    bool  osc_fill_bg            = input.bool (     true, "Fill Background", group=osc_colors, inline= "fill")
    int   osc_fill_alpha         = input.int  (       85,                     "", group=osc_colors, inline= "fill", minval=0, maxval=100)
    color osc_rising_bullish     = input.color(#FFCC00,     "Bullish Color", group=osc_colors, inline= "bull")
    color osc_rising_transition  = input.color(#9598A1,     "Transition Color", group=osc_colors, inline="range")
    color osc_falling_bearish    = input.color(#5500CC,     "Bearish Color", group=osc_colors, inline= "bear")

    var bool OSC_VOLATILITY_MODE_ON = osc_mode == "Volatility"


    osc_PhiSmoother(series float source, simple int length, simple float phase=3.7)=>
        var array<float> coefs = na
        var int length_1 = length - 1
        var float      W = 0.0
        if na(coefs)
            coefs := array.new<float>()
            const float SQRT_PIx2  = math.sqrt(2.0 * math.pi)
            const float MULTIPLIER = -0.5 / 0.93
            var float     length_2 = length * 0.52353
            for int i=0 to length_1
                float alpha = (i + phase - length_2) * MULTIPLIER
                float  beta = 1.0 / (0.2316419 * math.abs(alpha) + 1.0)
                float   phi = (math.exp(math.pow(alpha, 2) * -0.5)
                             *-0.398942280) * beta *
                             ( 0.319381530  + beta *
                             (-0.356563782  + beta *
                             ( 1.781477937  + beta *
                             (-1.821255978  + beta
                             * 1.330274429)))) + 1.011
                if alpha < 0.0
                    phi := 1.0 - phi
                float weight = phi / SQRT_PIx2
                coefs.push(weight)
                W += weight
        float sma2 = math.avg(source, nz(source[1], source))
        float E = 0.0
        for int i=0 to length_1
            E += coefs.get(i) * sma2[i]
        E / W

    osc_ema(series float source, simple float length)=>
        float alpha = 2.0 / (length + 1)
        var float smoothed = na
        smoothed := alpha * source + (1.0 - alpha) * nz(smoothed[1], source)

    osc_dema(series float source, simple float length)=>
        float ema1 = osc_ema(source, length)
        float ema2 = osc_ema(  ema1, length)
        2.0 * ema1 - ema2

    osc_tema(series float source, simple float length)=>
        float ema1 = osc_ema(source, length)
        float ema2 = osc_ema(  ema1, length)
        float ema3 = osc_ema(  ema2, length)
        (ema1 - ema2) * 3.0 + ema3

    osc_wma(series float source, simple int length)=>
        float weight_sum = length * 0.5 * (length + 1)
        float sum = 0.0
        for int i=0 to length - 1
            sum += source[i] * (length - i)
        sum / weight_sum

    osc_sma(series float source, simple int length)=>
        float sum = ta.cum(source)
        if bar_index < length - 1
            sum / (bar_index + 1)
        else
            (sum - sum[length]) / length

    osc_filter(series float source,
           simple int   length,
           simple float  phase,
           simple string style)=>
        if length > 1
            switch style
                "PhiSmoother" => osc_PhiSmoother(source, length, phase)
                "EMA"         =>         osc_ema(source, length)
                "DEMA"        =>        osc_dema(source, length)
                "TEMA"        =>        osc_tema(source, length)
                "WMA"         =>         osc_wma(source, length)
                =>                       osc_sma(source, length) // "SMA"
        else
            source

    osc_get_score(series array<float> source)=>
        array<float> scores = array.new<float>()
        for int i=0 to source.size() - 1
            float current = source.get(i)
            int score_sum = 0
            for j = 0 to source.size() - 1
                float check = source.get(j)
                int polarity = i < j ? 1 : -1
                if i != j
                    if current > check
                        score_sum += polarity
                    else
                        score_sum -= polarity
            scores.push(score_sum)
        scores

    osc_net_score_func(series array<float> scores)=>
        int   value    = scores.size() - 1
        float netScore = ((scores.avg() + value) / (value * 2.0) - 0.5) * 200.0
        netScore

    array<float> osc_filter_cluster = array.new<float>(34)
    osc_filter_cluster.set( 0,        osc_source)
    osc_filter_cluster.set( 1, osc_filter(osc_source,      osc_spacing, osc_phase, osc_filter_type))
    osc_filter_cluster.set( 2, osc_filter(osc_source, 2  * osc_spacing, osc_phase, osc_filter_type))
    osc_filter_cluster.set( 3, osc_filter(osc_source, 3  * osc_spacing, osc_phase, osc_filter_type))
    osc_filter_cluster.set( 4, osc_filter(osc_source, 4  * osc_spacing, osc_phase, osc_filter_type))
    osc_filter_cluster.set( 6, osc_filter(osc_source, 5  * osc_spacing, osc_phase, osc_filter_type))
    osc_filter_cluster.set( 7, osc_filter(osc_source, 6  * osc_spacing, osc_phase, osc_filter_type))
    osc_filter_cluster.set( 8, osc_filter(osc_source, 7  * osc_spacing, osc_phase, osc_filter_type))
    osc_filter_cluster.set( 9, osc_filter(osc_source, 8  * osc_spacing, osc_phase, osc_filter_type))
    osc_filter_cluster.set(10, osc_filter(osc_source, 9  * osc_spacing, osc_phase, osc_filter_type))
    osc_filter_cluster.set(11, osc_filter(osc_source, 10 * osc_spacing, osc_phase, osc_filter_type))
    osc_filter_cluster.set(12, osc_filter(osc_source, 11 * osc_spacing, osc_phase, osc_filter_type))
    osc_filter_cluster.set(13, osc_filter(osc_source, 12 * osc_spacing, osc_phase, osc_filter_type))
    osc_filter_cluster.set(14, osc_filter(osc_source, 13 * osc_spacing, osc_phase, osc_filter_type))
    osc_filter_cluster.set(15, osc_filter(osc_source, 14 * osc_spacing, osc_phase, osc_filter_type))
    osc_filter_cluster.set(16, osc_filter(osc_source, 15 * osc_spacing, osc_phase, osc_filter_type))
    osc_filter_cluster.set(17, osc_filter(osc_source, 16 * osc_spacing, osc_phase, osc_filter_type))
    osc_filter_cluster.set(18, osc_filter(osc_source, 17 * osc_spacing, osc_phase, osc_filter_type))
    osc_filter_cluster.set(19, osc_filter(osc_source, 18 * osc_spacing, osc_phase, osc_filter_type))
    osc_filter_cluster.set(20, osc_filter(osc_source, 19 * osc_spacing, osc_phase, osc_filter_type))
    osc_filter_cluster.set(21, osc_filter(osc_source, 20 * osc_spacing, osc_phase, osc_filter_type))
    osc_filter_cluster.set(22, osc_filter(osc_source, 21 * osc_spacing, osc_phase, osc_filter_type))
    osc_filter_cluster.set(23, osc_filter(osc_source, 22 * osc_spacing, osc_phase, osc_filter_type))
    osc_filter_cluster.set(24, osc_filter(osc_source, 23 * osc_spacing, osc_phase, osc_filter_type))
    osc_filter_cluster.set(25, osc_filter(osc_source, 24 * osc_spacing, osc_phase, osc_filter_type))
    osc_filter_cluster.set(26, osc_filter(osc_source, 25 * osc_spacing, osc_phase, osc_filter_type))
    osc_filter_cluster.set(27, osc_filter(osc_source, 26 * osc_spacing, osc_phase, osc_filter_type))
    osc_filter_cluster.set(28, osc_filter(osc_source, 27 * osc_spacing, osc_phase, osc_filter_type))
    osc_filter_cluster.set(29, osc_filter(osc_source, 28 * osc_spacing, osc_phase, osc_filter_type))
    osc_filter_cluster.set(30, osc_filter(osc_source, 29 * osc_spacing, osc_phase, osc_filter_type))
    osc_filter_cluster.set(31, osc_filter(osc_source, 30 * osc_spacing, osc_phase, osc_filter_type))
    osc_filter_cluster.set(32, osc_filter(osc_source, 31 * osc_spacing, osc_phase, osc_filter_type))
    osc_filter_cluster.set(33, osc_filter(osc_source, 32 * osc_spacing, osc_phase, osc_filter_type))

    if osc_upper_trim > 0
        for int i=0 to math.min(osc_upper_trim - 1, osc_filter_cluster.size() - 1)
            if  osc_filter_cluster.size() > 2
                osc_filter_cluster.shift()
            else
                break
    if osc_lower_trim > 0
        for int i=0 to math.min(osc_lower_trim - 1, osc_filter_cluster.size() - 1)
            if  osc_filter_cluster.size() > 2
                osc_filter_cluster.pop()
            else
                break

    float osc_ribbon_max   = osc_filter_cluster.max()
    float osc_ribbon_min   = osc_filter_cluster.min()
    float osc_ribbon_width = osc_ribbon_max - osc_ribbon_min
    float osc_ribbon_rank  = OSC_VOLATILITY_MODE_ON ? nz(osc_ribbon_width / math.avg(osc_ribbon_max, osc_ribbon_min)) : 1

    array<float> osc_score_arr = osc_get_score(osc_filter_cluster)
    float    osc_net_score = osc_filter(osc_net_score_func(osc_score_arr) * osc_ribbon_rank, osc_post_smooth_len, 3.7, osc_post_smooth_filt)
    float osc_signal_value = osc_signal_length < 2 ? na : osc_filter(ta.sma(osc_net_score, 2), osc_signal_length, 3.7, osc_signal_filter)

    osc_top    = hline(OSC_VOLATILITY_MODE_ON ? na :      100.0,    "Top",       color.red)
    osc_upper  = hline(OSC_VOLATILITY_MODE_ON ? na : osc_upperLevel, "+Level",  osc_rising_bullish, hline.style_dotted, 2)
    osc_center = hline(                                 0.0, "Center",       color.gray)
    osc_lower  = hline(OSC_VOLATILITY_MODE_ON ? na : osc_lowerLevel, "+Level", osc_falling_bearish, hline.style_dotted, 2)
    osc_bottom = hline(OSC_VOLATILITY_MODE_ON ? na :     -100.0, "Bottom",       color.green)

    osc_invisible = na
    fill(   osc_top, osc_upper,      100.0, osc_upperLevel, color.rgb(255, 0, 0, 80), osc_invisible)
    fill(osc_center, osc_upper, osc_upperLevel,        0.0, color.new( osc_rising_bullish, 100),  color.new(osc_rising_bullish, osc_fill_bg ? osc_fill_alpha : 100))
    fill(osc_center, osc_lower,        0.0, osc_lowerLevel, color.new(osc_falling_bearish, osc_fill_bg ? osc_fill_alpha : 100), color.new(osc_falling_bearish, 100))
    fill(osc_bottom, osc_lower, osc_lowerLevel,     -100.0, osc_invisible, color.rgb(0, 255, 0, 80))

    osc_color1 = osc_net_score>osc_signal_value ? color.green : color.red

    osc_net  = plot(osc_net_score, "Score", osc_color1, 3)
    osc_zero = plot(      0.0,      "", osc_invisible)
    plot(osc_signal_value, "Signal", osc_signal_color, 1)
    fill(osc_net, osc_zero,  osc_net_score > 0.0 ? osc_net_score : 0.0,
                     osc_net_score > 0.0 ? 0.0 : osc_net_score,
                     osc_net_score > 0.0 ? color.new(osc_rising_bullish, osc_fill_bg and OSC_VOLATILITY_MODE_ON ? osc_fill_alpha : 100) : color.new(osc_falling_bearish, 100),
                     osc_net_score > 0.0 ? color.new(osc_rising_bullish, 100) : color.new(osc_falling_bearish, osc_fill_bg and OSC_VOLATILITY_MODE_ON ? osc_fill_alpha : 100))

// --- NOTE ON PINESCRIPT V6 COLOR COMPATIBILITY ---
// This script uses the `color.new()` function in some places, which is deprecated in PineScript v6.
// This is necessary to allow for user-defined transparency on colors from the settings panel.
// The script will compile and run correctly, but you may see warnings in the editor.
// This is a known limitation, and the script will be updated if a better solution becomes available in future PineScript versions.

// --- VWAP Z-Score Indicator ---
if show_vwap_zscore
    string zscore_group = "--- VWAP Z-SCORE SETTINGS ---"
    zscore_len = input.int(20, title="VWAP Z-Score Length",group =zscore_group )
    zscore_upper_top = input.float(3.0, title="Upper Threshold Top",group =zscore_group)
    zscore_upper_bottom = input.float(2.5, title="Upper Threshold Bottom",group =zscore_group)
    zscore_lower_top = input.float(-3.0, title="Lower Threshold Top",group =zscore_group)
    zscore_lower_bottom = input.float(-2.5, title="Lower Threshold Bottom",group =zscore_group)
    zscore_showSignals = input.bool(true,title = "Show Reversal Signals",group =zscore_group)
    zscore_color_above_zero = input.color(#7FFF00, title="Line Color ",inline = "visual",group =zscore_group)
    zscore_color_below_zero = input.color(#FF00FF, title=" ",inline = "visual",group =zscore_group)
    zscore_buy_symbol = input.string("🔼", "Buy Symbol", options=["🔼", "BULL", "AGRESSIVE BULL"], group=zscore_group)
    zscore_sell_symbol = input.string("🔽", "Sell Symbol", options=["🔽", "BEAR", "AGRESSIVE BEAR"], group=zscore_group)


    zscore_calc_zvwap_enhanced(periods) =>
        vw_mean = math.sum(volume * close, periods) / math.sum(volume, periods)
        vw_sd = math.sqrt(ta.sma(math.pow(close - vw_mean, 2), periods))
        vwapz = (close - vw_mean) / vw_sd
        vwapz

    zscore_ub_high = plot(zscore_upper_top, title="Overbought High", color=color.rgb(255, 0, 0, 0))
    zscore_ub_low = plot(zscore_upper_bottom, title="Overbought Low", color=color.rgb(255, 0, 0, 0))
    fill(zscore_ub_high, zscore_ub_low, color=color.rgb(255, 0, 0, 90))

    zscore_os_high = plot(zscore_lower_top, title="Oversold High", color=color.rgb(0, 255, 0, 0))
    zscore_os_low = plot(zscore_lower_bottom, title="Oversold Low", color=color.rgb(0, 255, 0, 0))
    fill(zscore_os_high, zscore_os_low, color=color.rgb(0, 255, 0, 90))

    zscore_zvwap_val = zscore_calc_zvwap_enhanced(zscore_len)

    plot(zscore_zvwap_val, title="ZVWAP",
         color=zscore_zvwap_val >= 0 ? zscore_color_above_zero : zscore_color_below_zero,
         linewidth=2)

    zscore_alert_condition_up = zscore_zvwap_val > zscore_upper_bottom
    zscore_alert_condition_down = zscore_zvwap_val < zscore_lower_bottom

    plotshape(zscore_alert_condition_down and zscore_showSignals? zscore_zvwap_val - 1.2 : na, title="Support Signal", location=location.absolute, color=na, text=zscore_buy_symbol )
    plotshape(zscore_alert_condition_up and zscore_showSignals ? zscore_zvwap_val +0.3: na, title="Resistance Signal", location=location.absolute, color=na, text=zscore_sell_symbol )

    alertcondition(condition = zscore_alert_condition_down,title="VWAP Z-Score Buy", message="ZVWAP crossed above resistance")
    alertcondition(condition = zscore_alert_condition_up, title="VWAP Z-Score Sell", message="ZVWAP crossed below support")

// --- Standard Deviation Volatility Helper ---

// Custom types for StdDev Helper must be declared in the global scope.
type stddev_VolatilityBands
    float upper
    float lower

if show_stddev_helper
    string stddev_group = "--- STDDEV VOLATILITY HELPER SETTINGS ---"

    // User Inputs
    stddev_sdSrc     = input.source(close, "Standard Deviation Source", group=stddev_group, tooltip = "Price source used for calculating volatility bands (e.g., close price).")
    stddev_sdPeriod  = input.int(1,        "Standard Deviation Period", group=stddev_group, minval = 1, tooltip = "Multiplier period adjusting sensitivity of volatility bands. Higher values increase band range.")
    stddev_sdLength  = input.int(30,       "Standard Deviation Length", group=stddev_group, minval = 1, tooltip = "Number of bars used to calculate historical volatility. Higher length = smoother volatility measure.")
    stddev_smoothEma = input.bool(false,   "Enable EMA Smoothing?",     group=stddev_group, tooltip = "Applies an exponential moving average (EMA) to smooth oscillator output, reducing noise.")
    stddev_emaLength = input.int(20,       "EMA Smoothing Length",      group=stddev_group, minval = 1, tooltip = "Period length for EMA smoothing. Higher length increases smoothing effect.")


    // Function: Calculate Historical Volatility
    stddev_f_historicalVolatility(int len) =>
        float logReturns = math.log(close / close[1])
        ta.stdev(logReturns, len)

    // Function: Calculate Dynamic Volatility Bands
    stddev_f_volatilityBands(float src, float volatility, int period) =>
        float expFactor = math.exp(volatility * math.sqrt(period))
        stddev_VolatilityBands.new(upper = src * math.pow(expFactor, 3), lower = src / math.pow(expFactor, 3))

    // Main Calculation
    stddev_volatility = stddev_f_historicalVolatility(stddev_sdLength)
    stddev_bands      = stddev_f_volatilityBands(stddev_sdSrc, stddev_volatility, stddev_sdPeriod)

    // Volatility-based Oscillator Calculation
    float stddev_volOsc = ta.stoch(close, stddev_bands.upper, stddev_bands.lower, stddev_sdLength)

    // Optional EMA smoothing
    float stddev_volOscSmoothed = ta.ema(stddev_volOsc, stddev_emaLength)
    float stddev_output         = stddev_smoothEma ? stddev_volOscSmoothed : stddev_volOsc

    // Plotting
    plot(stddev_output, "Volatility Oscillator", color = color.rgb(0, 160, 255), linewidth = 2)
    hline(80, title = "Overbought",       color = color.red, linestyle = hline.style_dashed)
    hline(50, title = "Neutral",          color = color.gray, linestyle = hline.style_dashed)
    hline(20, title = "Oversold",         color = color.green, linestyle = hline.style_dashed)

    // Alerts
    alertcondition(stddev_output > 80, title = "Overbought Alert", message = "Oscillator entered overbought territory (>80)")
    alertcondition(stddev_output < 20, title = "Oversold Alert",   message = "Oscillator entered oversold territory (<20)"  )
